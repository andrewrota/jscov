fs = require 'fs'
path = require 'path'
_ = require 'underscore'
esprima = require 'esprima'
escodegen = require 'escodegen'
wrench = require 'wrench'
coffee = require 'coffee-script'
tools = require './tools'
estools = require './estools'
jscoverageFormatting = require './jscoverage-formatting'



coverageVar = '_$jscoverage'



writeFile = do ->
  sourceMappings = [
    (x) -> x.replace(/&/g, '&amp;')
    (x) -> x.replace(/</g, '&lt;')
    (x) -> x.replace(/>/g, '&gt;')
    (x) -> x.replace(/\\/g, '\\\\')
    (x) -> x.replace(/"/g, '\\"')
    (x) -> tools.strToNumericEntity(x)
    (x) -> '"' + x + '"'
  ]

  (originalCode, coveredCode, filename, trackedLines) ->

    originalSource = originalCode.split(/\r?\n/g).map (line) -> sourceMappings.reduce(((src, f) -> f(src)), line)
    originalSource = originalSource.slice(0, -1) if _.last(originalSource) == '""'

    output = []
    output.push "/* automatically generated by jscov - do not edit */"
    output.push "if (typeof #{coverageVar} === 'undefined') #{coverageVar} = {};"
    output.push "if (!#{coverageVar}['#{filename}']) {"
    output.push "  #{coverageVar}['#{filename}'] = [];"
    trackedLines.forEach (line) ->
      output.push "  #{coverageVar}['#{filename}'][#{line}] = 0;"
    output.push "}"
    output.push coveredCode
    output.push "#{coverageVar}['#{filename}'].source = [" + originalSource.join(",") + "];"

    output.join('\n') # should maybe windows style line-endings be used here in some cases?



exports.rewriteSource = (code, filename) ->

  injectList = []

  ast = esprima.parse(code, { loc: true })

  jscoverageFormatting.formatTree(ast)

  # all optional blocks should be actual blocks (in order to make it possible to put coverage information in them)
  escodegen.traverse ast,
    enter: (node) ->
      if node.type == 'IfStatement'
        ['consequent', 'alternate'].forEach (src) ->
          if node[src]? && node[src].type != 'BlockStatement'
            node[src] =
              type: 'BlockStatement'
              body: [node[src]]
      if node.type in ['ForInStatement', 'ForStatement', 'WhileStatement', 'WithStatement', 'DoWhileStatement'] && node.body? && node.body.type != 'BlockStatement'
        node.body =
          type: 'BlockStatement'
          body: [node.body]

  # insert the coverage information
  escodegen.traverse ast,
    enter: (node) ->
      if node.type in ['BlockStatement', 'Program']
        node.body = _.flatten node.body.map (x) ->
          if x.expression?.type == 'FunctionExpression'
            injectList.push(x.expression.loc.start.line)
            [estools.coverageNode(x.expression, filename, coverageVar), x]
          else if x.expression?.type == 'CallExpression'
            injectList.push(x.expression.loc.start.line)
            [estools.coverageNode(x.expression, filename, coverageVar), x]
          else if x.type == 'FunctionDeclaration'
            injectList.push(x.body.loc.start.line)
            [estools.coverageNode(x.body, filename, coverageVar), x]
          else
            injectList.push(x.loc.start.line)
            [estools.coverageNode(x, filename, coverageVar), x]
      if node.type == 'SwitchCase'
        node.consequent = _.flatten node.consequent.map (x) ->
          injectList.push(x.loc.start.line)
          [estools.coverageNode(x, filename, coverageVar), x]

  # wrap it up
  trackedLines = _.sortBy(_.unique(injectList), _.identity)
  outcode = escodegen.generate(ast, { indent: "  " })
  writeFile(code, outcode, filename, trackedLines)



exports.rewriteFolder = (source, target, options, callback) ->
  try
    if !callback?
      callback = options
      options = {}

    wrench.rmdirSyncRecursive(target, true)

    wrench.readdirSyncRecursive(source).forEach (file) ->
      fullpath = path.join(source, file)
      return if fs.lstatSync(fullpath).isDirectory()

      data = fs.readFileSync(fullpath, 'utf8')

      if file.match(/\.coffee$/)
        data = coffee.compile(data)
      else if !file.match(/\.js$/)
        data = null

      if data != null
        output = exports.rewriteSource(data, file)
        outfile = path.join(target, file).replace(/\.coffee$/, '.js')
        wrench.mkdirSyncRecursive(path.dirname(outfile))
        fs.writeFileSync(outfile, output, 'utf8')

  catch ex
    callback(ex)
    return

  callback(null)
